{"title":"NumPy 学习笔记：第二阶段 - 核心技能","uid":"b34a2d20ebaf2f1ab87598c5d48f72ca","slug":"NumPy-学习笔记：第二阶段-核心技能","date":"2025-07-07T09:23:26.000Z","updated":"2025-07-07T10:24:13.120Z","comments":true,"path":"api/articles/NumPy-学习笔记：第二阶段-核心技能.json","keywords":null,"cover":null,"content":"<h2 id=\"NumPy-学习笔记：第二阶段-核心技能\"><a href=\"#NumPy-学习笔记：第二阶段-核心技能\" class=\"headerlink\" title=\"NumPy 学习笔记：第二阶段 - 核心技能\"></a><strong>NumPy 学习笔记：第二阶段 - 核心技能</strong></h2><h3 id=\"5-数组的数学运算\"><a href=\"#5-数组的数学运算\" class=\"headerlink\" title=\"5. 数组的数学运算\"></a><strong>5. 数组的数学运算</strong></h3><p>掌握 NumPy 的数学运算是利用其强大性能的关键。核心思想是<strong>向量化</strong>，即直接对整个数组进行操作，而不是使用 Python 的 <code>for</code> 循环来遍历每个元素。这不仅代码更简洁，执行效率也天差地别。</p>\n<h4 id=\"5-1-元素级运算-Element-wise-Operations\"><a href=\"#5-1-元素级运算-Element-wise-Operations\" class=\"headerlink\" title=\"5.1 元素级运算 (Element-wise Operations)\"></a><strong>5.1 元素级运算 (Element-wise Operations)</strong></h4><p>元素级运算是指对数组中的每一个元素独立地执行相同的操作。当两个数组形状相同时，算术运算符和通用函数（ufunc）会自动执行元素级运算。</p>\n<p><strong>a) 算术运算</strong></p>\n<p>你可以像操作普通数字一样，对 NumPy 数组使用标准的算术运算符。</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">import numpy as np\n\n# 创建两个形状相同的数组\na = np.array([[1, 2, 3], [4, 5, 6]])\nb = np.array([[10, 11, 12], [13, 14, 15]])\n\nprint(f\"数组 a:\\n{a}\\n\")\nprint(f\"数组 b:\\n{b}\\n\")\n\n# 元素级加法\nprint(f\"a + b:\\n{a + b}\\n\")\n\n# 元素级减法\nprint(f\"b - a:\\n{b - a}\\n\")\n\n# 元素级乘法\nprint(f\"a * b:\\n{a * b}\\n\")\n\n# 元素级除法\nprint(f\"b / a:\\n{b / a}\\n\")\n\n# 元素级幂运算\nprint(f\"a ** 2:\\n{a ** 2}\\n\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>数组 a:\n[[1 2 3]\n [4 5 6]]\n\n数组 b:\n[[10 11 12]\n [13 14 15]]\n\na + b:\n[[11 13 15]\n [17 19 21]]\n\nb - a:\n[[9 9 9]\n [9 9 9]]\n\na * b:\n[[10 22 36]\n [52 70 90]]\n\nb / a:\n[[10.    5.5   4.  ]\n [ 3.25  2.8   2.5 ]]\n\na ** 2:\n[[ 1  4  9]\n [16 25 36]]\n</code></pre><p><strong>b) 通用函数 (Universal Functions, ufunc)</strong></p>\n<p>NumPy 提供了大量优化的数学函数，它们也以元素级的方式作用于数组。</p>\n<p>包括<code>np.sqrt</code>, <code>np.exp</code>, <code>np.sin</code>, <code>np.log</code>等等</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">arr = np.array([1, 4, 9, 16])\nprint(f\"原始数组: {arr}\\n\")\n\n# 计算每个元素的平方根\nprint(f\"平方根 (np.sqrt): {np.sqrt(arr)}\")\n\n# 计算每个元素的指数 (e^x)\nprint(f\"指数 (np.exp): {np.exp(arr)}\")\n\n# 计算每个元素的正弦值\ntrig_arr = np.array([0, np.pi/2, np.pi])\nprint(f\"三角函数数组: {trig_arr}\")\nprint(f\"正弦值 (np.sin): {np.sin(trig_arr)}\")\n\n# 计算每个元素的自然对数\nlog_arr = np.array([1, np.e, 10]) # np.e 是自然常数 e\nprint(f\"\\n对数数组: {log_arr}\")\nprint(f\"自然对数 (np.log): {np.log(log_arr)}\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>原始数组: [ 1  4  9 16]\n\n平方根 (np.sqrt): [1. 2. 3. 4.]\n指数 (np.exp): [2.71828183e+00 5.45981500e+01 8.10308393e+03 8.88611052e+06]\n三角函数数组: [0.         1.57079633 3.14159265]\n正弦值 (np.sin): [0.0000000e+00 1.0000000e+00 1.2246468e-16]\n\n对数数组: [ 1.          2.71828183 10.        ]\n自然对数 (np.log): [0.         1.         2.30258509]\n</code></pre><h4 id=\"5-2-聚合运算-Aggregation\"><a href=\"#5-2-聚合运算-Aggregation\" class=\"headerlink\" title=\"5.2 聚合运算 (Aggregation)\"></a><strong>5.2 聚合运算 (Aggregation)</strong></h4><p>聚合运算是指对一组值（例如整个数组或数组的某一行/列）执行计算，最终返回一个单一值的操作。</p>\n<p><strong>a) 对整个数组进行聚合</strong></p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">data = np.array([[1, 2, 3], [4, 5, 6]])\nprint(f\"数据数组:\\n{data}\\n\")\n\n# 计算所有元素的总和\nprint(f\"总和 (data.sum()): {data.sum()}\") # 等价于 np.sum(data)\n\n# 计算所有元素的最小值\nprint(f\"最小值 (data.min()): {data.min()}\")\n\n# 计算所有元素的最大值\nprint(f\"最大值 (data.max()): {data.max()}\")\n\n# 计算所有元素的平均值\nprint(f\"平均值 (data.mean()): {data.mean()}\")\n\n# 计算所有元素的标准差\nprint(f\"标准差 (data.std()): {data.std()}\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>数据数组:\n[[1 2 3]\n [4 5 6]]\n\n总和 (data.sum()): 21\n最小值 (data.min()): 1\n最大值 (data.max()): 6\n平均值 (data.mean()): 3.5\n标准差 (data.std()): 1.707825127659933\n</code></pre><p><strong>b) 指定轴向的聚合 (Axis-specific Aggregation)</strong></p>\n<p>这是 NumPy 中一个极其重要的概念。通过指定 <code>axis</code> 参数，你可以沿着数组的特定维度（轴）进行聚合。</p>\n<ul>\n<li><code>axis=0</code>: 沿着<strong>行</strong>的方向进行操作，可以理解为“压缩行”，对每一<strong>列</strong>进行聚合。</li>\n<li><code>axis=1</code>: 沿着<strong>列</strong>的方向进行操作，可以理解为“压缩列”，对每一<strong>行</strong>进行聚合。</li>\n</ul>\n<p><strong>图解:</strong><br>对于一个 2x3 的数组 <code>[[a, b, c], [d, e, f]]</code>：</p>\n<ul>\n<li><code>sum(axis=0)</code> 的结果是 <code>[a+d, b+e, c+f]</code> (形状变为 <code>(3,)</code>)</li>\n<li><code>sum(axis=1)</code> 的结果是 <code>[a+b+c, d+e+f]</code> (形状变为 <code>(2,)</code>)</li>\n</ul>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">data = np.array([[1, 2, 3], [4, 5, 6]])\nprint(f\"数据数组:\\n{data}\\n\")\n\n# 沿 axis=0 (对每一列) 求和\ncol_sums = data.sum(axis=0)\nprint(f\"沿 axis=0 求和 (各列之和): {col_sums}\")\nprint(f\"结果形状: {col_sums.shape}\\n\")\n\n# 沿 axis=1 (对每一行) 求和\nrow_sums = data.sum(axis=1)\nprint(f\"沿 axis=1 求和 (各行之和): {row_sums}\")\nprint(f\"结果形状: {row_sums.shape}\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>数据数组:\n[[1 2 3]\n [4 5 6]]\n\n沿 axis=0 求和 (各列之和): [5 7 9]\n结果形状: (3,)\n\n沿 axis=1 求和 (各行之和): [ 6 15]\n结果形状: (2,)\n</code></pre><h3 id=\"6-广播-Broadcasting\"><a href=\"#6-广播-Broadcasting\" class=\"headerlink\" title=\"6. 广播 (Broadcasting)\"></a><strong>6. 广播 (Broadcasting)</strong></h3><p>广播是 NumPy 最强大也最核心的功能之一。它描述了 NumPy 在处理<strong>形状不同</strong>的数组时如何进行算术运算，而无需显式地复制数据。这使得代码更简洁，内存使用更高效。</p>\n<h4 id=\"6-1-广播的核心规则\"><a href=\"#6-1-广播的核心规则\" class=\"headerlink\" title=\"6.1 广播的核心规则\"></a><strong>6.1 广播的核心规则</strong></h4><p>当对两个数组进行操作时，NumPy 会逐个比较它们的维度（从末尾开始）。要满足广播条件，必须符合以下两个规则：</p>\n<ol>\n<li><strong>规则一:</strong> 如果两个数组的维度数不同，那么在维度较小的数组的<strong>形状前面补 1</strong>，直到它们的维度数相同。</li>\n<li><strong>规则二:</strong> 在任何一个维度上，如果两个数组的该维度大小相同，或者其中一个数组的大小为 1，那么它们在该维度上是兼容的。</li>\n</ol>\n<p>如果这两个规则都满足，就可以进行广播。计算结果的每个维度的大小是输入数组在该维度上的最大值。如果不满足，NumPy 会抛出 <code>ValueError</code>。</p>\n<h4 id=\"6-2-广播的实际应用\"><a href=\"#6-2-广播的实际应用\" class=\"headerlink\" title=\"6.2 广播的实际应用\"></a><strong>6.2 广播的实际应用</strong></h4><p><strong>情况一：数组与标量（单个数值）的运算</strong><br>这是最简单也最常见的广播。</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">arr = np.array([[1, 2, 3], [4, 5, 6]])\nscalar = 10\n\n# 数组与标量相加\nresult = arr + scalar\nprint(f\"数组 arr (shape: {arr.shape}):\\n{arr}\\n\")\nprint(f\"标量 scalar: {scalar}\\n\")\nprint(f\"广播结果 (shape: {result.shape}):\\n{result}\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>数组 arr (shape: (2, 3)):\n[[1 2 3]\n [4 5 6]]\n\n标量 scalar: 10\n\n广播结果 (shape: (2, 3)):\n[[11 12 13]\n [14 15 16]]\n</code></pre><p><strong>广播过程:</strong></p>\n<ol>\n<li><code>arr</code> 的形状是 <code>(2, 3)</code>。<code>scalar</code> 可以看作形状为 <code>()</code> 的数组。</li>\n<li><strong>规则一:</strong> 将 <code>scalar</code> 的形状补齐为 <code>(1, 1)</code>，再补齐为 <code>(2, 3)</code> 以匹配 <code>arr</code>。</li>\n<li><strong>规则二:</strong> 在每个维度上，将大小为 1 的维度“拉伸”以匹配另一个数组。最终 <code>scalar</code> 被广播成 <code>[[10, 10, 10], [10, 10, 10]]</code>，然后与 <code>arr</code> 进行元素级相加。</li>\n</ol>\n<p><strong>情况二：二维数组与一维数组的运算</strong></p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">matrix = np.arange(12).reshape(3, 4) # 形状 (3, 4)\nvector = np.array([10, 20, 30, 40])  # 形状 (4,)\n\n# 将 vector 加到 matrix 的每一行\nresult = matrix + vector\nprint(f\"矩阵 matrix (shape: {matrix.shape}):\\n{matrix}\\n\")\nprint(f\"向量 vector (shape: {vector.shape}): {vector}\\n\")\nprint(f\"广播结果 (shape: {result.shape}):\\n{result}\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>矩阵 matrix (shape: (3, 4)):\n[[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n\n向量 vector (shape: (4,)): [10 20 30 40]\n\n广播结果 (shape: (3, 4)):\n[[10 21 32 43]\n [14 25 36 47]\n [18 29 40 51]]\n</code></pre><p><strong>广播过程:</strong></p>\n<ol>\n<li><code>matrix</code> 形状 <code>(3, 4)</code>，<code>vector</code> 形状 <code>(4,)</code>。</li>\n<li><strong>规则一:</strong> 给 <code>vector</code> 的形状前面补 1，变为 <code>(1, 4)</code>。</li>\n<li><strong>规则二:</strong> 现在比较 <code>(3, 4)</code> 和 <code>(1, 4)</code>。<ul>\n<li>末尾维度：大小都是 4，兼容。</li>\n<li>第一个维度：大小分别为 3 和 1，兼容。</li>\n</ul>\n</li>\n<li>NumPy 将 <code>vector</code> (形状 <code>(1, 4)</code>) 沿着大小为 1 的轴（<code>axis=0</code>）“拉伸”3次，使其行为与形状为 <code>(3, 4)</code> 的数组一致，然后与 <code>matrix</code> 相加。</li>\n</ol>\n<p><strong>情况三：两个不同形状的数组</strong><br>假设我们要给一个列向量加上一个行向量。</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">col_vector = np.array([[10], [20], [30]]) # 形状 (3, 1)\nrow_vector = np.array([1, 2, 3, 4])      # 形状 (4,)，广播时视为 (1, 4)\n\nresult = col_vector + row_vector\nprint(f\"列向量 (shape: {col_vector.shape}):\\n{col_vector}\\n\")\nprint(f\"行向量 (shape: {row_vector.shape}): {row_vector}\\n\")\nprint(f\"广播结果 (shape: {result.shape}):\\n{result}\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>列向量 (shape: (3, 1)):\n[[10]\n [20]\n [30]]\n\n行向量 (shape: (4,)): [1 2 3 4]\n\n广播结果 (shape: (3, 4)):\n[[11 12 13 14]\n [21 22 23 24]\n [31 32 33 34]]\n</code></pre><p><strong>广播过程:</strong></p>\n<ol>\n<li><code>col_vector</code> 形状 <code>(3, 1)</code>，<code>row_vector</code> 形状 <code>(4,)</code>。</li>\n<li><strong>规则一:</strong> <code>row_vector</code> 形状补齐为 <code>(1, 4)</code>。</li>\n<li><strong>规则二:</strong> 现在比较 <code>(3, 1)</code> 和 <code>(1, 4)</code>。<ul>\n<li>末尾维度：大小分别为 1 和 4，兼容。</li>\n<li>第一个维度：大小分别为 3 和 1，兼容。</li>\n</ul>\n</li>\n<li>结果数组的形状是 <code>(max(3, 1), max(1, 4))</code>，即 <code>(3, 4)</code>。<code>col_vector</code> 沿着 <code>axis=1</code> 广播，<code>row_vector</code> 沿着 <code>axis=0</code> 广播，最终两者都被扩展成 <code>(3, 4)</code> 的形状进行相加。</li>\n</ol>\n<p><strong>广播失败的例子</strong></p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">a = np.array([[1, 2, 3]]) # 形状 (1, 3)\nb = np.array([[4, 5]])    # 形状 (1, 2)\n\ntry:\n    c = a + b\nexcept ValueError as e:\n    print(f\"广播失败，错误信息: {e}\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>广播失败，错误信息: operands could not be broadcast together with shapes (1,3) (1,2)\n</code></pre><p><strong>原因:</strong> 比较 <code>(1, 3)</code> 和 <code>(1, 2)</code>。末尾维度的大小分别为 3 和 2，既不相等，也没有一个是 1，因此不满足广播规则。</p>\n<h3 id=\"7-高级索引-Advanced-Indexing\"><a href=\"#7-高级索引-Advanced-Indexing\" class=\"headerlink\" title=\"7. 高级索引 (Advanced Indexing)\"></a><strong>7. 高级索引 (Advanced Indexing)</strong></h3><p>当基本的切片（如 <code>arr[0:5]</code>）无法满足复杂的选取需求时，高级索引就派上了用场。它提供了基于条件或索引列表来访问和修改数据的强大能力。</p>\n<h4 id=\"7-1-布尔索引-Boolean-Indexing\"><a href=\"#7-1-布尔索引-Boolean-Indexing\" class=\"headerlink\" title=\"7.1 布尔索引 (Boolean Indexing)\"></a><strong>7.1 布尔索引 (Boolean Indexing)</strong></h4><p>布尔索引允许我们使用一个布尔类型的数组（通常称为<strong>掩码 (mask)</strong>）来筛选另一个数组中的元素。这在数据清洗和筛选中极为常用。</p>\n<p><strong>核心思想：</strong> 创建一个与原数组形状相同的布尔数组，其中 <code>True</code> 值对应的位置就是我们希望选取的元素。</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">import numpy as np\n\n# 创建一个示例数组\ndata = np.arange(12).reshape(3, 4)\nprint(f\"原始数组:\\n{data}\\n\")\n\n# 1. 创建一个简单的布尔掩码\n# 条件：选取所有大于 5 的元素\nmask = data > 5\nprint(f\"布尔掩码 (data > 5):\\n{mask}\\n\")\n\n# 2. 使用掩码进行索引\n# 这会返回一个一维数组，其中只包含所有满足条件的元素\nselected_data = data[mask]\nprint(f\"使用掩码选取的结果: {selected_data}\")\nprint(\"注意：布尔索引返回的是数据的副本 (Copy)，而不是视图。\\n\")\n\n# 3. 结合逻辑运算符进行复杂筛选\n# 条件：选取大于 3 且小于 8 的元素\n# 注意：必须使用 & (与), | (或), ~ (非) 位运算符，且每个条件要用括号括起来\ncomplex_mask = (data > 3) & (data < 8)\nprint(f\"复杂条件掩码 ((data > 3) & (data < 8)):\\n{complex_mask}\\n\")\nprint(f\"复杂筛选结果: {data[complex_mask]}\\n\")\n\n# 4. 使用布尔索引进行赋值\n# 将所有偶数替换为 -1\ndata[data % 2 == 0] = -1\nprint(f\"将所有偶数替换为 -1 后的数组:\\n{data}\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>原始数组:\n[[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n\n布尔掩码 (data &gt; 5):\n[[False False False False]\n [False False  True  True]\n [ True  True  True  True]]\n\n使用掩码选取的结果: [ 6  7  8  9 10 11]\n注意：布尔索引返回的是数据的副本 (Copy)，而不是视图。\n\n复杂条件掩码 ((data &gt; 3) &amp; (data &lt; 8)):\n[[False False False False]\n [ True  True  True  True]\n [False False False False]]\n\n复杂筛选结果: [4 5 6 7]\n\n将所有偶数替换为 -1 后的数组:\n[[-1  1 -1  3]\n [-1  5 -1  7]\n [-1  9 -1 11]]\n</code></pre><h4 id=\"7-2-花式索引-Fancy-Indexing\"><a href=\"#7-2-花式索引-Fancy-Indexing\" class=\"headerlink\" title=\"7.2 花式索引 (Fancy Indexing)\"></a><strong>7.2 花式索引 (Fancy Indexing)</strong></h4><p>花式索引使用一个整数数组或列表来指定要访问的元素的索引。这使得我们可以选取任意不连续的元素、重复元素或以任意顺序排列元素。</p>\n<p><strong>重要概念：</strong> 花式索引<strong>总是</strong>返回数据的<strong>副本 (Copy)</strong>，而不是视图。</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\"># 创建一个示例数组\narr = np.arange(10) * 10  # [ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\nprint(f\"原始一维数组: {arr}\\n\")\n\n# 1. 在一维数组中使用花式索引\n# 选取索引为 1, 3, 8 的元素\nindices = [1, 3, 8]\nprint(f\"选取索引为 [1, 3, 8] 的元素: {arr[indices]}\\n\")\n\n# 2. 在多维数组中使用花式索引\nmatrix = np.arange(9).reshape(3, 3)\nprint(f\"原始二维数组:\\n{matrix}\\n\")\n\n# 选取特定的行，例如第 0 行和第 2 行\nselected_rows = matrix[[0, 2]]\nprint(f\"选取第 0 行和第 2 行:\\n{selected_rows}\\n\")\n\n# 选取特定的点 (行和列索引配对)\n# 选取 (0, 1), (1, 2), (2, 0) 三个位置的元素\nrows = [0, 1, 2]\ncols = [1, 2, 0]\nselected_points = matrix[rows, cols]\nprint(f\"选取点 (0,1), (1,2), (2,0): {selected_points}\\n\")\n\n# 3. 使用花式索引进行赋值\n# 将索引为 1, 3, 8 的元素修改为 -99\narr[[1, 3, 8]] = -99\nprint(f\"使用花式索引赋值后: {arr}\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>原始一维数组: [ 0 10 20 30 40 50 60 70 80 90]\n\n选取索引为 [1, 3, 8] 的元素: [10 30 80]\n\n原始二维数组:\n[[0 1 2]\n [3 4 5]\n [6 7 8]]\n\n选取第 0 行和第 2 行:\n[[0 1 2]\n [6 7 8]]\n\n选取点 (0,1), (1,2), (2,0): [1 5 6]\n\n使用花式索引赋值后: [  0 -99  20 -99  40  50  60  70 -99  90]\n</code></pre><h3 id=\"8-数组形状操作\"><a href=\"#8-数组形状操作\" class=\"headerlink\" title=\"8. 数组形状操作\"></a><strong>8. 数组形状操作</strong></h3><p>在数据预处理和模型输入准备中，我们经常需要改变数组的维度和结构，而 NumPy 提供了多种高效的工具来完成这些任务。</p>\n<h4 id=\"8-1-reshape-改变形状\"><a href=\"#8-1-reshape-改变形状\" class=\"headerlink\" title=\"8.1 reshape(): 改变形状\"></a><strong>8.1 <code>reshape()</code>: 改变形状</strong></h4><p><code>reshape()</code> 在不改变原始数据的情况下，返回一个具有新形状的数组。</p>\n<ul>\n<li>新形状的元素总数必须与原形状的元素总数相同。</li>\n<li><code>reshape()</code> 尽可能返回一个<strong>视图 (View)</strong>，以避免数据复制，提高效率。</li>\n<li>可以使用 <code>-1</code> 作为维度参数，让 NumPy 自动计算该维度的大小。</li>\n</ul>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">a = np.arange(12)\nprint(f\"原始数组 (shape: {a.shape}): {a}\\n\")\n\n# 重塑为 3x4 的矩阵\nb = a.reshape(3, 4)\nprint(f\"重塑后的 3x4 矩阵:\\n{b}\\n\")\n\n# 使用 -1 自动计算维度\n# 原始数组有 12 个元素，指定 2 列，行数自动计算为 6\nc = a.reshape(-1, 2)\nprint(f\"自动计算行数 (-1, 2):\\n{c}\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>原始数组 (shape: (12,)): [ 0  1  2  3  4  5  6  7  8  9 10 11]\n\n重塑后的 3x4 矩阵:\n[[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n\n自动计算行数 (-1, 2):\n[[ 0  1]\n [ 2  3]\n [ 4  5]\n [ 6  7]\n [ 8  9]\n [10 11]]\n</code></pre><h4 id=\"8-2-ravel-与-flatten-数组展平\"><a href=\"#8-2-ravel-与-flatten-数组展平\" class=\"headerlink\" title=\"8.2 ravel() 与 flatten(): 数组展平\"></a><strong>8.2 <code>ravel()</code> 与 <code>flatten()</code>: 数组展平</strong></h4><p>这两个函数都能将多维数组转换为一维数组，但有一个关键区别：</p>\n<ul>\n<li><code>ravel()</code>: “散开”，尽可能返回一个<strong>视图 (View)</strong>，修改它可能会影响原始数组。</li>\n<li><code>flatten()</code>: “压平”，总是返回一个<strong>副本 (Copy)</strong>，修改它绝不会影响原始数组。</li>\n</ul>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">matrix = np.arange(6).reshape(2, 3)\nprint(f\"原始矩阵:\\n{matrix}\\n\")\n\n# 使用 ravel()\nraveled_arr = matrix.ravel()\nraveled_arr[0] = 100 # 修改视图\nprint(f\"Ravel 展平结果: {raveled_arr}\")\nprint(f\"原始矩阵被修改了:\\n{matrix}\\n\")\n\n# 恢复原始矩阵\nmatrix[0, 0] = 0\n\n# 使用 flatten()\nflattened_arr = matrix.flatten()\nflattened_arr[0] = 200 # 修改副本\nprint(f\"Flatten 展平结果: {flattened_arr}\")\nprint(f\"原始矩阵未被修改:\\n{matrix}\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>原始矩阵:\n[[0 1 2]\n [3 4 5]]\n\nRavel 展平结果: [100   1   2   3   4   5]\n原始矩阵被修改了:\n[[100   1   2]\n [  3   4   5]]\n\nFlatten 展平结果: [200   1   2   3   4   5]\n原始矩阵未被修改:\n[[0 1 2]\n [3 4 5]]\n</code></pre><p><strong>选择建议：</strong> 如果不希望修改原数组，或者不确定后续操作，使用 <code>flatten()</code> 更安全。如果注重性能且清楚自己在做什么，可以使用 <code>ravel()</code>。</p>\n<h4 id=\"8-3-transpose-或-T-属性-数组转置\"><a href=\"#8-3-transpose-或-T-属性-数组转置\" class=\"headerlink\" title=\"8.3 transpose() 或 .T 属性: 数组转置\"></a><strong>8.3 <code>transpose()</code> 或 <code>.T</code> 属性: 数组转置</strong></h4><p>转置操作会交换数组的轴。对于二维数组，就是交换行和列。转置返回的是一个<strong>视图 (View)</strong>。</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">matrix = np.arange(6).reshape(2, 3)\nprint(f\"原始矩阵 (2x3):\\n{matrix}\\n\")\n\n# 使用 .T 属性进行转置\ntransposed_matrix = matrix.T\nprint(f\"转置后的矩阵 (3x2):\\n{transposed_matrix}\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>原始矩阵 (2x3):\n[[0 1 2]\n [3 4 5]]\n\n转置后的矩阵 (3x2):\n[[0 3]\n [1 4]\n [2 5]]\n</code></pre><h4 id=\"8-4-resize-就地修改形状\"><a href=\"#8-4-resize-就地修改形状\" class=\"headerlink\" title=\"8.4 resize(): 就地修改形状\"></a><strong>8.4 <code>resize()</code>: 就地修改形状</strong></h4><p><code>resize()</code> 直接在<strong>原地 (in-place)</strong> 修改数组的形状，并且<strong>不要求</strong>新旧形状的元素总数一致。</p>\n<ul>\n<li>如果新尺寸更大，会用原数组的重复内容来填充。</li>\n<li>如果新尺寸更小，会截断原数组。</li>\n</ul>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">a = np.arange(4)\nprint(f\"原始数组: {a}\\n\")\n\n# resize 会直接修改 a，没有返回值\na.resize(2, 3)\nprint(f\"Resize 到 (2, 3) 后 (用 0 填充，因为没有足够元素重复):\\n{a}\")\n# 注意：如果 NumPy 认为有其他变量引用了该内存，可能会报错。\n# np.resize(array, new_shape) 是一个更安全的选择，它返回副本。\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>原始数组: [0 1 2 3]\n\nResize 到 (2, 3) 后 (用 0 填充，因为没有足够元素重复):\n[[0 1 2]\n [3 0 0]]\n</code></pre><h4 id=\"8-5-数组的拼接与分割\"><a href=\"#8-5-数组的拼接与分割\" class=\"headerlink\" title=\"8.5 数组的拼接与分割\"></a><strong>8.5 数组的拼接与分割</strong></h4><p><strong>a) 拼接 (Concatenation)</strong></p>\n<ul>\n<li><code>np.concatenate((a, b, ...), axis=...)</code>: 沿指定轴连接一系列数组。</li>\n<li><code>np.vstack((a, b))</code>: 垂直堆叠 (Vertical Stack)，等价于 <code>concatenate</code> 的 <code>axis=0</code>。</li>\n<li><code>np.hstack((a, b))</code>: 水平堆叠 (Horizontal Stack)，等价于 <code>concatenate</code> 的 <code>axis=1</code>。</li>\n</ul>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">a = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6]])\nprint(f\"数组 a:\\n{a}\\n数组 b:\\n{b}\\n\")\n\n# 垂直拼接 (axis=0)\nv_stacked = np.vstack((a, b))\nprint(f\"垂直拼接 vstack (axis=0):\\n{v_stacked}\\n\")\n\n# 水平拼接 (需要 b 的形状匹配)\nc = np.array([[5], [6]])\nh_stacked = np.hstack((a, c))\nprint(f\"数组 c:\\n{c}\\n水平拼接 hstack (axis=1):\\n{h_stacked}\\n\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>数组 a:\n[[1 2]\n [3 4]]\n数组 b:\n[[5 6]]\n\n垂直拼接 vstack (axis=0):\n[[1 2]\n [3 4]\n [5 6]]\n\n数组 c:\n[[5]\n [6]]\n水平拼接 hstack (axis=1):\n[[1 2 5]\n [3 4 6]]\n</code></pre><p><strong>b) 分割 (Splitting)</strong></p>\n<ul>\n<li><code>np.split(arr, N, axis=...)</code>: 将数组沿指定轴平均分割成 N份。</li>\n<li><code>np.split(arr, [idx1, idx2, ...], axis=...)</code>: 在指定的索引位置进行分割。</li>\n<li><code>np.vsplit(arr, N)</code>: 垂直分割，等价于 <code>split</code> 的 <code>axis=0</code>。</li>\n<li><code>np.hsplit(arr, N)</code>: 水平分割，等价于 <code>split</code> 的 <code>axis=1</code>。</li>\n</ul>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">arr = np.arange(12).reshape(4, 3)\nprint(f\"待分割的数组:\\n{arr}\\n\")\n\n# 垂直分割成 2 份\nparts = np.vsplit(arr, 2)\nprint(f\"垂直分割成 2 份:\\n第一部分:\\n{parts[0]}\\n第二部分:\\n{parts[1]}\\n\")\n\n# 水平分割成 3 份\nparts_h = np.hsplit(arr, 3)\nprint(f\"水平分割成 3 份:\\n第一部分:\\n{parts_h[0]}\\n第二部分:\\n{parts_h[1]}\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>待分割的数组:\n[[ 0  1  2]\n [ 3  4  5]\n [ 6  7  8]\n [ 9 10 11]]\n\n垂直分割成 2 份:\n第一部分:\n[[0 1 2]\n [3 4 5]]\n第二部分:\n[[ 6  7  8]\n [ 9 10 11]]\n\n水平分割成 3 份:\n第一部分:\n[[0]\n [3]\n [6]\n [9]]\n第二部分:\n[[ 1]\n [ 4]\n [ 7]\n [10]]\n</code></pre>","text":"这个阶段的目标是掌握 NumPy 更高级的数组操作和核心功能，这是进行数据分析和科学计算的基础...","permalink":"/post/NumPy-学习笔记：第二阶段-核心技能","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"python语法学习","slug":"python语法学习","count":2,"path":"api/categories/python语法学习.json"}],"tags":[{"name":"python","slug":"python","count":2,"path":"api/tags/python.json"},{"name":"Numpy","slug":"Numpy","count":2,"path":"api/tags/Numpy.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NumPy-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-%E6%A0%B8%E5%BF%83%E6%8A%80%E8%83%BD\"><span class=\"toc-text\">NumPy 学习笔记：第二阶段 - 核心技能</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">5. 数组的数学运算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-%E5%85%83%E7%B4%A0%E7%BA%A7%E8%BF%90%E7%AE%97-Element-wise-Operations\"><span class=\"toc-text\">5.1 元素级运算 (Element-wise Operations)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-%E8%81%9A%E5%90%88%E8%BF%90%E7%AE%97-Aggregation\"><span class=\"toc-text\">5.2 聚合运算 (Aggregation)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%B9%BF%E6%92%AD-Broadcasting\"><span class=\"toc-text\">6. 广播 (Broadcasting)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-1-%E5%B9%BF%E6%92%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E8%A7%84%E5%88%99\"><span class=\"toc-text\">6.1 广播的核心规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-2-%E5%B9%BF%E6%92%AD%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">6.2 广播的实际应用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E9%AB%98%E7%BA%A7%E7%B4%A2%E5%BC%95-Advanced-Indexing\"><span class=\"toc-text\">7. 高级索引 (Advanced Indexing)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-1-%E5%B8%83%E5%B0%94%E7%B4%A2%E5%BC%95-Boolean-Indexing\"><span class=\"toc-text\">7.1 布尔索引 (Boolean Indexing)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-2-%E8%8A%B1%E5%BC%8F%E7%B4%A2%E5%BC%95-Fancy-Indexing\"><span class=\"toc-text\">7.2 花式索引 (Fancy Indexing)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E6%95%B0%E7%BB%84%E5%BD%A2%E7%8A%B6%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">8. 数组形状操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-1-reshape-%E6%94%B9%E5%8F%98%E5%BD%A2%E7%8A%B6\"><span class=\"toc-text\">8.1 reshape(): 改变形状</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-2-ravel-%E4%B8%8E-flatten-%E6%95%B0%E7%BB%84%E5%B1%95%E5%B9%B3\"><span class=\"toc-text\">8.2 ravel() 与 flatten(): 数组展平</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-3-transpose-%E6%88%96-T-%E5%B1%9E%E6%80%A7-%E6%95%B0%E7%BB%84%E8%BD%AC%E7%BD%AE\"><span class=\"toc-text\">8.3 transpose() 或 .T 属性: 数组转置</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-4-resize-%E5%B0%B1%E5%9C%B0%E4%BF%AE%E6%94%B9%E5%BD%A2%E7%8A%B6\"><span class=\"toc-text\">8.4 resize(): 就地修改形状</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-5-%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%BC%E6%8E%A5%E4%B8%8E%E5%88%86%E5%89%B2\"><span class=\"toc-text\">8.5 数组的拼接与分割</span></a></li></ol></li></ol></li></ol>","author":{"name":"犬夜叉","slug":"blog-author","avatar":"https://i.imgur.com/CrgPA5H_d.png?maxwidth=520&shape=thumb&fidelity=high","link":"/","description":"一位喜欢犬夜叉的多模态大模型研究生","socials":{"github":"https://github.com/ziyi-wang2003","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_62954485?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"ALBEF论文精读","uid":"5cac6105e8bc407ec91f6896ed602917","slug":"ALBEF论文精读","date":"2025-07-03T03:20:45.000Z","updated":"2025-07-07T06:29:20.677Z","comments":true,"path":"api/articles/ALBEF论文精读.json","keywords":null,"cover":"https://i.imgur.com/GDGylHi_d.png?maxwidth=520&shape=thumb&fidelity=high","text":"论文提出 ALBEF 框架，通过对比损失对齐图文表示，结合动量蒸馏处理噪声数据，在多任务上性能优于 SOTA。...","permalink":"/post/ALBEF论文精读","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"论文精读","slug":"论文精读","count":6,"path":"api/categories/论文精读.json"}],"tags":[{"name":"多模态","slug":"多模态","count":5,"path":"api/tags/多模态.json"},{"name":"VLP","slug":"VLP","count":2,"path":"api/tags/VLP.json"}],"author":{"name":"犬夜叉","slug":"blog-author","avatar":"https://i.imgur.com/CrgPA5H_d.png?maxwidth=520&shape=thumb&fidelity=high","link":"/","description":"一位喜欢犬夜叉的多模态大模型研究生","socials":{"github":"https://github.com/ziyi-wang2003","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_62954485?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"NumPy 学习笔记：第一阶段 - 入门基础","uid":"ba03d7c748f55c669d509a2713c39e98","slug":"NumPy-学习笔记：第一阶段-入门基础","date":"2025-07-07T08:45:52.000Z","updated":"2025-07-07T09:19:42.298Z","comments":true,"path":"api/articles/NumPy-学习笔记：第一阶段-入门基础.json","keywords":null,"cover":null,"text":"这个阶段的目标是理解 NumPy 的核心概念，并掌握其最基本的操作...","permalink":"/post/NumPy-学习笔记：第一阶段-入门基础","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"python语法学习","slug":"python语法学习","count":2,"path":"api/categories/python语法学习.json"}],"tags":[{"name":"python","slug":"python","count":2,"path":"api/tags/python.json"},{"name":"Numpy","slug":"Numpy","count":2,"path":"api/tags/Numpy.json"}],"author":{"name":"犬夜叉","slug":"blog-author","avatar":"https://i.imgur.com/CrgPA5H_d.png?maxwidth=520&shape=thumb&fidelity=high","link":"/","description":"一位喜欢犬夜叉的多模态大模型研究生","socials":{"github":"https://github.com/ziyi-wang2003","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_62954485?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}